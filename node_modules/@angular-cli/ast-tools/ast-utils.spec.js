"use strict";
var denodeify = require('denodeify');
var mockFs = require('mock-fs');
var ts = require('typescript');
var fs = require('fs');
var change_1 = require('./change');
var ast_utils_1 = require('./ast-utils');
var node_1 = require('./node');
var spec_utils_1 = require('./spec-utils');
var readFile = denodeify(fs.readFile);
describe('ast-utils: findNodes', function () {
    var sourceFile = 'tmp/tmp.ts';
    beforeEach(function () {
        var mockDrive = {
            'tmp': {
                'tmp.ts': "import * as myTest from 'tests' \n" +
                    'hello.'
            }
        };
        mockFs(mockDrive);
    });
    afterEach(function () {
        mockFs.restore();
    });
    spec_utils_1.it('finds no imports', function () {
        var editedFile = new change_1.RemoveChange(sourceFile, 0, "import * as myTest from 'tests' \n");
        return editedFile
            .apply()
            .then(function () {
            var rootNode = getRootNode(sourceFile);
            var nodes = node_1.findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);
            expect(nodes).toEqual([]);
        });
    });
    spec_utils_1.it('finds one import', function () {
        var rootNode = getRootNode(sourceFile);
        var nodes = node_1.findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);
        expect(nodes.length).toEqual(1);
    });
    spec_utils_1.it('finds two imports from inline declarations', function () {
        // remove new line and add an inline import
        var editedFile = new change_1.RemoveChange(sourceFile, 32, '\n');
        return editedFile
            .apply()
            .then(function () {
            var insert = new change_1.InsertChange(sourceFile, 32, "import {Routes} from '@angular/routes'");
            return insert.apply();
        })
            .then(function () {
            var rootNode = getRootNode(sourceFile);
            var nodes = node_1.findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);
            expect(nodes.length).toEqual(2);
        });
    });
    spec_utils_1.it('finds two imports from new line separated declarations', function () {
        var editedFile = new change_1.InsertChange(sourceFile, 33, "import {Routes} from '@angular/routes'");
        return editedFile
            .apply()
            .then(function () {
            var rootNode = getRootNode(sourceFile);
            var nodes = node_1.findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);
            expect(nodes.length).toEqual(2);
        });
    });
});
describe('ast-utils: insertAfterLastOccurrence', function () {
    var sourceFile = 'tmp/tmp.ts';
    beforeEach(function () {
        var mockDrive = {
            'tmp': {
                'tmp.ts': ''
            }
        };
        mockFs(mockDrive);
    });
    afterEach(function () {
        mockFs.restore();
    });
    spec_utils_1.it('inserts at beginning of file', function () {
        var imports = getNodesOfKind(ts.SyntaxKind.ImportDeclaration, sourceFile);
        return ast_utils_1.insertAfterLastOccurrence(imports, "\nimport { Router } from '@angular/router';", sourceFile, 0)
            .apply()
            .then(function () {
            return readFile(sourceFile, 'utf8');
        }).then(function (content) {
            var expected = '\nimport { Router } from \'@angular/router\';';
            expect(content).toEqual(expected);
        });
    });
    spec_utils_1.it('throws an error if first occurence with no fallback position', function () {
        var imports = getNodesOfKind(ts.SyntaxKind.ImportDeclaration, sourceFile);
        expect(function () { return ast_utils_1.insertAfterLastOccurrence(imports, "import { Router } from '@angular/router';", sourceFile); }).toThrowError();
    });
    spec_utils_1.it('inserts after last import', function () {
        var content = "import { foo, bar } from 'fizz';";
        var editedFile = new change_1.InsertChange(sourceFile, 0, content);
        return editedFile
            .apply()
            .then(function () {
            var imports = getNodesOfKind(ts.SyntaxKind.ImportDeclaration, sourceFile);
            return ast_utils_1.insertAfterLastOccurrence(imports, ', baz', sourceFile, 0, ts.SyntaxKind.Identifier)
                .apply();
        })
            .then(function () {
            return readFile(sourceFile, 'utf8');
        })
            .then(function (newContent) { return expect(newContent).toEqual("import { foo, bar, baz } from 'fizz';"); });
    });
    spec_utils_1.it('inserts after last import declaration', function () {
        var content = "import * from 'foo' \n import { bar } from 'baz'";
        var editedFile = new change_1.InsertChange(sourceFile, 0, content);
        return editedFile
            .apply()
            .then(function () {
            var imports = getNodesOfKind(ts.SyntaxKind.ImportDeclaration, sourceFile);
            return ast_utils_1.insertAfterLastOccurrence(imports, "\nimport Router from '@angular/router'", sourceFile)
                .apply();
        })
            .then(function () {
            return readFile(sourceFile, 'utf8');
        })
            .then(function (newContent) {
            var expected = "import * from 'foo' \n import { bar } from 'baz'" +
                "\nimport Router from '@angular/router'";
            expect(newContent).toEqual(expected);
        });
    });
    spec_utils_1.it('inserts correctly if no imports', function () {
        var content = "import {} from 'foo'";
        var editedFile = new change_1.InsertChange(sourceFile, 0, content);
        return editedFile
            .apply()
            .then(function () {
            var imports = getNodesOfKind(ts.SyntaxKind.ImportDeclaration, sourceFile);
            return ast_utils_1.insertAfterLastOccurrence(imports, ', bar', sourceFile, undefined, ts.SyntaxKind.Identifier)
                .apply();
        })
            .catch(function () {
            return readFile(sourceFile, 'utf8');
        })
            .then(function (newContent) {
            expect(newContent).toEqual(content);
            // use a fallback position for safety
            var imports = getNodesOfKind(ts.SyntaxKind.ImportDeclaration, sourceFile);
            var pos = node_1.findNodes(imports.sort(function (a, b) { return a.pos - b.pos; }).pop(), ts.SyntaxKind.CloseBraceToken).pop().pos;
            return ast_utils_1.insertAfterLastOccurrence(imports, ' bar ', sourceFile, pos, ts.SyntaxKind.Identifier)
                .apply();
        })
            .then(function () {
            return readFile(sourceFile, 'utf8');
        })
            .then(function (newContent) {
            expect(newContent).toEqual("import { bar } from 'foo'");
        });
    });
});
describe('addComponentToModule', function () {
    beforeEach(function () {
        mockFs({
            '1.ts': "\nimport {NgModule} from '@angular/core';\n\n@NgModule({\n  declarations: []\n})\nclass Module {}",
            '2.ts': "\nimport {NgModule} from '@angular/core';\n\n@NgModule({\n  declarations: [\n    Other\n  ]\n})\nclass Module {}",
            '3.ts': "\nimport {NgModule} from '@angular/core';\n\n@NgModule({\n})\nclass Module {}",
            '4.ts': "\nimport {NgModule} from '@angular/core';\n\n@NgModule({\n  field1: [],\n  field2: {}\n})\nclass Module {}"
        });
    });
    afterEach(function () { return mockFs.restore(); });
    spec_utils_1.it('works with empty array', function () {
        return ast_utils_1.addComponentToModule('1.ts', 'MyClass', 'MyImportPath')
            .then(function (change) { return change.apply(); })
            .then(function () { return readFile('1.ts', 'utf-8'); })
            .then(function (content) {
            expect(content).toEqual('\n' +
                'import {NgModule} from \'@angular/core\';\n' +
                'import { MyClass } from \'MyImportPath\';\n' +
                '\n' +
                '@NgModule({\n' +
                '  declarations: [MyClass]\n' +
                '})\n' +
                'class Module {}');
        });
    });
    spec_utils_1.it('works with array with declarations', function () {
        return ast_utils_1.addComponentToModule('2.ts', 'MyClass', 'MyImportPath')
            .then(function (change) { return change.apply(); })
            .then(function () { return readFile('2.ts', 'utf-8'); })
            .then(function (content) {
            expect(content).toEqual('\n' +
                'import {NgModule} from \'@angular/core\';\n' +
                'import { MyClass } from \'MyImportPath\';\n' +
                '\n' +
                '@NgModule({\n' +
                '  declarations: [\n' +
                '    Other,\n' +
                '    MyClass\n' +
                '  ]\n' +
                '})\n' +
                'class Module {}');
        });
    });
    spec_utils_1.it('works without any declarations', function () {
        return ast_utils_1.addComponentToModule('3.ts', 'MyClass', 'MyImportPath')
            .then(function (change) { return change.apply(); })
            .then(function () { return readFile('3.ts', 'utf-8'); })
            .then(function (content) {
            expect(content).toEqual('\n' +
                'import {NgModule} from \'@angular/core\';\n' +
                'import { MyClass } from \'MyImportPath\';\n' +
                '\n' +
                '@NgModule({\n' +
                '  declarations: [MyClass]\n' +
                '})\n' +
                'class Module {}');
        });
    });
    spec_utils_1.it('works without a declaration field', function () {
        return ast_utils_1.addComponentToModule('4.ts', 'MyClass', 'MyImportPath')
            .then(function (change) { return change.apply(); })
            .then(function () { return readFile('4.ts', 'utf-8'); })
            .then(function (content) {
            expect(content).toEqual('\n' +
                'import {NgModule} from \'@angular/core\';\n' +
                'import { MyClass } from \'MyImportPath\';\n' +
                '\n' +
                '@NgModule({\n' +
                '  field1: [],\n' +
                '  field2: {},\n' +
                '  declarations: [MyClass]\n' +
                '})\n' +
                'class Module {}');
        });
    });
});
/**
 * Gets node of kind kind from sourceFile
 */
function getNodesOfKind(kind, sourceFile) {
    return node_1.findNodes(getRootNode(sourceFile), kind);
}
function getRootNode(sourceFile) {
    return ts.createSourceFile(sourceFile, fs.readFileSync(sourceFile).toString(), ts.ScriptTarget.ES6, true);
}
//# sourceMappingURL=/Users/hans/Sources/angular-cli/packages/ast-tools/src/ast-utils.spec.js.map